// AUTO-GENERATED

#ifndef _GI_GTK_TEXTAPPEARANCE_IMPL_HPP_
#define _GI_GTK_TEXTAPPEARANCE_IMPL_HPP_

namespace gi {

namespace repository {

namespace Gtk {

namespace base {

static gint _field_rise_get (const ::GtkTextAppearance* obj) { return (gint) obj->rise; }
// gint TextAppearance::rise (const ::GtkTextAppearance* obj);
// gint TextAppearance::rise (const ::GtkTextAppearance* obj);
gint base::TextAppearanceBase::rise_ () const noexcept
{
  typedef gint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_rise_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_rise_set (::GtkTextAppearance* obj, gint _value) { obj->rise = (decltype(obj->rise)) _value; }
//  TextAppearance::rise (::GtkTextAppearance* obj, gint _value);
// void TextAppearance::rise (::GtkTextAppearance* obj, gint _value);
void base::TextAppearanceBase::rise_ (gint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, gint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_rise_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (gint) (_value_to_c));
}

static guint _field_underline_get (const ::GtkTextAppearance* obj) { return (guint) obj->underline; }
// guint TextAppearance::underline (const ::GtkTextAppearance* obj);
// guint TextAppearance::underline (const ::GtkTextAppearance* obj);
guint base::TextAppearanceBase::underline_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_underline_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_underline_set (::GtkTextAppearance* obj, guint _value) { obj->underline = (decltype(obj->underline)) _value; }
//  TextAppearance::underline (::GtkTextAppearance* obj, guint _value);
// void TextAppearance::underline (::GtkTextAppearance* obj, guint _value);
void base::TextAppearanceBase::underline_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_underline_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_strikethrough_get (const ::GtkTextAppearance* obj) { return (guint) obj->strikethrough; }
// guint TextAppearance::strikethrough (const ::GtkTextAppearance* obj);
// guint TextAppearance::strikethrough (const ::GtkTextAppearance* obj);
guint base::TextAppearanceBase::strikethrough_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_strikethrough_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_strikethrough_set (::GtkTextAppearance* obj, guint _value) { obj->strikethrough = (decltype(obj->strikethrough)) _value; }
//  TextAppearance::strikethrough (::GtkTextAppearance* obj, guint _value);
// void TextAppearance::strikethrough (::GtkTextAppearance* obj, guint _value);
void base::TextAppearanceBase::strikethrough_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_strikethrough_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_draw_bg_get (const ::GtkTextAppearance* obj) { return (guint) obj->draw_bg; }
// guint TextAppearance::draw_bg (const ::GtkTextAppearance* obj);
// guint TextAppearance::draw_bg (const ::GtkTextAppearance* obj);
guint base::TextAppearanceBase::draw_bg_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_draw_bg_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_draw_bg_set (::GtkTextAppearance* obj, guint _value) { obj->draw_bg = (decltype(obj->draw_bg)) _value; }
//  TextAppearance::draw_bg (::GtkTextAppearance* obj, guint _value);
// void TextAppearance::draw_bg (::GtkTextAppearance* obj, guint _value);
void base::TextAppearanceBase::draw_bg_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_draw_bg_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_inside_selection_get (const ::GtkTextAppearance* obj) { return (guint) obj->inside_selection; }
// guint TextAppearance::inside_selection (const ::GtkTextAppearance* obj);
// guint TextAppearance::inside_selection (const ::GtkTextAppearance* obj);
guint base::TextAppearanceBase::inside_selection_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_inside_selection_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_inside_selection_set (::GtkTextAppearance* obj, guint _value) { obj->inside_selection = (decltype(obj->inside_selection)) _value; }
//  TextAppearance::inside_selection (::GtkTextAppearance* obj, guint _value);
// void TextAppearance::inside_selection (::GtkTextAppearance* obj, guint _value);
void base::TextAppearanceBase::inside_selection_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_inside_selection_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_text_get (const ::GtkTextAppearance* obj) { return (guint) obj->is_text; }
// guint TextAppearance::is_text (const ::GtkTextAppearance* obj);
// guint TextAppearance::is_text (const ::GtkTextAppearance* obj);
guint base::TextAppearanceBase::is_text_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::GtkTextAppearance* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_text_get;
  auto _temp_ret = call_wrap_v ((const ::GtkTextAppearance*) (gobj_()));
  return _temp_ret;
}

static void _field_is_text_set (::GtkTextAppearance* obj, guint _value) { obj->is_text = (decltype(obj->is_text)) _value; }
//  TextAppearance::is_text (::GtkTextAppearance* obj, guint _value);
// void TextAppearance::is_text (::GtkTextAppearance* obj, guint _value);
void base::TextAppearanceBase::is_text_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::GtkTextAppearance* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_text_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GtkTextAppearance*) (gobj_()), (guint) (_value_to_c));
}


} // namespace base

} // namespace Gtk

} // namespace repository

} // namespace gi


#if defined(__has_include)
#if __has_include(<gtk/textappearance_extra_def_impl.hpp>)
#include <gtk/textappearance_extra_def_impl.hpp>
#endif
#endif


#if defined(__has_include)
#if __has_include(<gtk/textappearance_extra_impl.hpp>)
#include <gtk/textappearance_extra_impl.hpp>
#endif
#endif

#endif
